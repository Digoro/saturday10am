# Angular
* Angular 버저닝
* 컴포넌트 기반
* 모듈 로딩
* zone.js 변경 감지
* 서버 사이드 렌더링
* 웹워커
* AOT 컴파일과 Tree Shaking

## Angular 버저닝  
> *AngularJS에서 Angular로, Angular 2에서 3을 뛰어 넘어 Angular 4로, 중간 중간 마이너 버전과 메이저 버전의 업데이트까지 Angular의 버저닝은 개발자들에게 혼란을 줄 수 있는 여지가 많다. 왜 이렇게 복잡할까?*

### AngularJS --> Angular

**AngularJS의 등장**  
Angular는 2009년 구글의 미시코 헤브리가 처음 개발하여 2010년 0.9버전으로 정식 릴리즈되었으며 2012년 6월에 1.0 버전이 릴리즈 되었다. 단 몇 개월만에 혁신적인 생산성으로 가장 인기있는 프론트엔드 프레임워크로 자리잡았으며, 그 후 1.6.9 버전까지 릴리즈되었다.(더이상 지원하지 않는다.)

**Angular로 업그레이드**  
그 후 약 4년 뒤인 2016년 9월에 Angular 2.0 버전이 정식 릴리즈 되었다. AngularJS 1.x와 전혀 호환이 되지 않으며 기반 언어도 타입스크립트를 타겟으로 구현이 되어 있다. 기존 1.x 버전을 익힌 것은 모두 무용지물이 되고 새로운 프레임워크와 언어를 다시 습득해야하기에 개발자들은 혼란에 빠진다. 기존 버전과 혼란을 막기 위해 2.0 버전부터는 새로운 이름을 달아야 한다는 의견이 대세가 되고 AngularJS에서 Angular로 JS가 삭제 되었다.(Angular는 더이상 라이브러리 수준이 아닌 프레임워크로 진화했기 때문이다.)

### Angular 버저닝 정책

**시맨틱 버전**  
Angular는 기본적으로 시맨틱 버저닝 정책을 따른다. 시맨틱 버저닝 정책은 다음과 같다.
* 메이저 버전: 과거 버전과 호환되지 않음
* 마이너 버전: 과거 버전과 호환이 되며 새로운 기능이 추가
* 패치 버전: 버그 픽스

![https://q.vtable.org/semantic-versioning-cool-concept-buuuut/](/img/semantic_versioning.png)  

**Angular 3은 어디에?**   
@angular/router의 버전이 2.0 개발 중 대규모 변경이 이루어지고 다른 모듈은 2.0인 시점에 3.0으로 업데이트해야만 했다. 이렇게되면 개발자들은 Angular 모듈 버전에 대해 더 큰 혼란을 가져다 온다고 판단하여 메이저 3버전을 건너뛰고 4버전으로 이어갔다.

## 컴포넌트 기반  
> *사람의 사고능력은 제한적이라서 전체를 한꺼번에 세부적으로 처리할 수 없다. 그래서 무언가를 만들 때 큰 단위로 추상화를 한 후에 부분 별로 작업하거 이를 결합하는 사고방식에 익숙하다. 이를 Angular는 컴포넌트 단위로 개발 할 수 있도록 하였다.*

**복잡한 HTML들**  
기존에는 페이지 별로 복잡한 HTML 파일들을 수십개씩 처리해야 했다. 이것을 한꺼번에 처리하는 것은 매우 복잡하며 인내가 필요할 것이다. 적절히 추상화를 하여 구조를 만들 수 있는 도구가 없었기 때문이다. 이 때의 개발 방식과 도구는 자연스러운 사고 방식을 반영하지 못한다고 볼 수 있다.

**AngularJS의 방식**  
AngularJS를 사용하더라도 상황은 마찬가지이다. 가장 많이 하는 작업이 컨트롤러를 생성하고 HTML에 붙이는 작업이다. 뷰와 컨트롤러를 잘 분리해주고 데이터 바인딩을 자동화하여 매우 번거롭던 일들을 대폭 줄여준 것은 맞지만 우리의 자연스러운 사고 방식을 반영하지 못하였다.

**컴포넌트 기반 구조**  
웹 어플리케이션의 부분 부분을 컴포넌트로 구분하고 각 컴포넌트는 자신만의 클래스, 태그 등으로 나타내지기 때문에 HTML의 나열이 아니라 컴포넌트 단위의 UI로 구성되게 된다.
또한 컴포넌트는 컴포넌트 별로 또 하위 컴포넌트들을 조합하여 자체적인 구조를 만들게 되며 전체적으로 컴포넌트 트리를 이루게된다.
이렇게 되면 트리의 각 단계에서 보는 추상화 단위로 애플리케이션을 보기 때문에 구조 파악이 쉬워지며 작업의 단위도 컴포넌트로 분리할 수 있어 유지보수나 수정이 용이하다.

**Angular의 컴포넌트 구조**  
Angular에서는 어플리케이션을 컴포넌트로 개발할 수밖에 없게 되어 있다. UI를 구성하려면 무조건 컴포넌트를 정의해야한다. 다음은 간단한 Angular 컴포넌트의 예시이다.
```javascript
@Component({
	selector: "sat10amApp",
    	template: 
		<h1>App Component</h1> 
		<button (click)="onClick()">click</button>,
    	styles: [
    		h1 { background-color: red }
	]
})
export class AppComponent {
	onClick() { alert("Clicked")}
}
```
Angular가 위와 같은 컴포넌트 구조를 도입하였기 때문에 다음과 같은 이점을 얻을 수 있다.
* Angular의 컴포넌트를 하나의 클래스로 다루도록 해서 훨씬 객체지향적이다. 코드로 모두 표현하기 힘든 설정은 데코레이터를 적절히 사용해 클래스에 추가하기도 했다.

* AngularJS에서는 scope를 통해 템플릿과 컨트롤러의 중간 저장 공간이 있어 임의로 삽임될 때 바인딩이 의도와 다르게 동작하는 경우가 많았지만 Angular에서는 템플릿에 대한 모든 바인딩이 컴포넌트 클래스의 멤버 변수 또는 함수로 고정되어 있다. 따라서 어플리케이션의 구조가 명확해지고 작동 결과를 예상하기가 쉬워졌다.  
![http://frontend.diffthink.kr/2016/05/angular-02-angularjs.html](/img/angularjs_scope.png)  


* Angular는 Shadow Dom을 지원하여 컴포넌트에 정의된 CSS 스타일 요소가 지역적으로 적용되도록 구현되어있다. 컴포넌트의 디자인 요소까지 지역화 할 수 있기 때문에 컴포넌트의 독립성과 재사용성이 크게 증가한다.

* 라우터 설정에서도 컴포넌트 기반이 유용하다. Angular의 라우팅 정의는 라우팅에 따라 변경되는 부분을 컴포넌트로 설정한다. 라우팅에 대해 변경되는 부분이라는 것은 독립된 UI와 독립된 기능이라는 것이기 때문에 이런 부분은 컴포넌트라는 단위로 표현하는 것이 더 자연스럽고 적절하다.
```javascript
const routes: Routes = [
  { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
  { path: 'dashboard', component: DashboardComponent },
  { path: 'detail/:id', component: AccountDetailComponent },
  { path: 'accounts', component: AccountComponent }
];
```

* 이 외에도 변경 감지나 기타 설정들이 컴포넌트 단위로 이루어지도록 하고 있다.
